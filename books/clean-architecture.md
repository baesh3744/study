# 클린 아키텍처

> 로버트 C. 마틴

## 1부. 소개

### 1장. 설계와 아키텍처란?

- 설계<sub><span style='color: grey'>design</span></sub>와 아키텍처<sub><span style='color: grey'>architecture</span></sub> 사이에는 차이가 없다.
  - 일반적으로 설계는 저수준의 세부사항, 아키텍처는 고수준의 구조를 말한다.
  - 설계와 아키텍처는 개별로 존재할 수 없고, 구분 짓는 경계도 뚜렷하지 않다. 따라서 이 둘의 구분은 무의미하다.
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
  - 코드를 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.
- 자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.
- 어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장. 두 가지 가치에 대한 이야기

- 모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공한다: 행위<sub><span style='color: grey'>behavior</span></sub>와 구조<sub><span style='color: grey'>structure</span></sub>. 소프트웨어 개발자는 두 가치를 모두 높게 유지해야 하는 책임을 진다.

#### 행위

- 많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신이 해야 할 일의 전부라고 생각한다. 슬픈 일이지만 그들은 틀렸다!

#### 아키텍처

- 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 (기계의 행위를) 변경하기 쉬워야 한다.
  - 변경사항을 적용하는 데 드는 어려움은 변경되는 범위<sub><span style='color: grey'>scope</span></sub>에 비례해야 하며, 변경사항의 형태<sub><span style='color: grey'>shape</span></sub>와는 관련이 없어야 한다.
  - 새로운 요구사항이 발생할 때마다 더 힘들어지는 이유는 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문이다.
  - 흔히 소프트웨어 개발자는 사각형 마개를 동그란 구멍에 밀어넣도록 강요받는 느낌을 받는다.
- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아키텍처를 위해 투쟁하라
  - 아이젠하워 매트릭스에 따른 우선순위는 다음과 같다.
    1. 긴급하고 중요한 (행위, 기능)
    2. 긴급하지는 않지만 중요한 (아키텍처)
    3. 긴급하지만 중요하지 않은 (행위, 기능)
    4. 긴급하지도 중요하지도 않은
  - 업무 관리자와 개발자가 흔히 저지르는 실수는 긴급하지만 중요하지 않은 기능과 긴급하면서 중요한 기능을 구분하지 못한다. 이로 인해 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
  - 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.

## 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임<sub><span style='color: grey'>paradigm</span></sub>이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

### 3장. 패러다임 개요

#### 구조적 프로그래밍<sub><span style='color: grey'>structured programming</span></sub>

- 최초로 적용된 패러다임이다. (최초로 만들어진 패러다임은 아니다.)
- 1968년, 에츠허르 비버 데이트스트라<sub><span style='color: grey'>Edsger Wybe Dijkstra</span></sub>가 발견했다.
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

#### 객체 지향 프로그래밍<sub><span style='color: grey'>object-oriented programming</span></sub>

- 1966년, 올레 요한 달<sub><span style='color: grey'>Ole Johan Dahl</span></sub>과 크리스텐 니가드<sub><span style='color: grey'>Kristen Nygaard</span></sub>에 의해 등장했다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

#### 함수형 프로그래밍<sub><span style='color: grey'>functional programming</span></sub>

- 최근에 들어서야 도입되기 시작했지만, 세 패러다임 중 가장 먼저 만들어졌다.
- 알론조 처치<sub><span style='color: grey'>Alonzo Church</span></sub>는 어떤 수학적 문제를 해결하는 과정에서 람다<sub><span style='color: grey'>lambda</span></sub> 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.
- 1958년, 존 매카시<sub><span style='color: grey'>John McCarthy</span></sub>가 만든 LISP 언어의 근간이 되는 개념이 람다 계산법이다.
- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

#### 결론

- 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- 프로그래밍 패러다임은 앞으로도 딱 세 가지밖에 없을 것이다.
  - why?
    - 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다. 우리에게서 가져갈 수 있는 게 더 없다.
    - 이들 패러다임은 1958년 ~ 1968년에 걸친 10년 동안 모두 만들어졌다. 이후로 수십 년이 지났지만, 새롭게 등장한 패러다임은 없다.

### 4장. 구조적 프로그래밍

- 데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.

#### 증명

- 데이크스트라는 증명<sub><span style='color: grey'>proof</span></sub>이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.
  - 그는 수학자가 유클리드 계층구조 (공리, 정리, 따름정리, 보조정리) 를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.
  - 다시 말해, 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식
- goto
  - 모듈을 재귀적으로 분해하는 과정에 방해 -> 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없다.
  - '좋은' 사용 방식은 분기 (if/then/else) 와 반복 (do/while) 이라는 단순한 제어 구조에 해당한다.
- 뵘<sub><span style='color: grey'>Böhm</span></sub>과 야코피니<sub><span style='color: grey'>Jacopini</span></sub>: 모든 프로그램은 순차<sub><span style='color: grey'>sequence</span></sub>, 분기<sub><span style='color: grey'>selection</span></sub>, 반복<sub><span style='color: grey'>iteration</span></sub>이라는 세 가지 구조만으로 표현할 수 있다.
- 즉, 모듈을 증명 가능하게 하는 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다.
- 데이크스트라의 증명
  - 순차 구문 by 열거법
  - 분기 by 열거법
  - 반복 by 귀납법<sub><span style='color: grey'>induction</span></sub>
- 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다. (수학적인 증명의 실패)

#### 과학적 방법

- 수학 vs. 과학
  - 수학은 증명 가능한 서술이 참임을 입증하는 원리이다.
  - 과학은 증명 가능한 서술이 거짓임을 입증하는 원리이다.
- 소프트웨어는 과학과 같다.
  - 데이크스트라: "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다."
  - 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여준다.
  - 프로그램을 증명 가능한 세부 기능 집합으로 분해 -> 세부 기능들이 거짓임을 증명하려는 테스트가 실패 -> 이 기능들은 목표에 부합할 만큼은 충분히 참이다.

#### 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유
  - 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있다.
  - 대다수의 현대적 언어는 제약 없는 goto 문장을 지원하지 않는다.
    - 현재의 우리 모두는 구조적 프로그래머이다.
  - 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여긴다.
- **소프트웨어 아키텍처는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 (테스트하기 쉽도록) 만들기 위해 노력해야 한다.**

### 5장. 객체 지향 프로그래밍

- **좋은 아키텍처를 만드는 일은 객체 지향<sub><span style='color: grey'>OO, Object-Oriented</span></sub> 설계 원칙을 이해하고 응용하는 데서 출발한다.**
- OO란 무엇인가?
  - "데이터와 함수의 조합"
    - `o.f()`가 왠지 `f(o)`와 다르다는 의미를 내포하기 때문에 만족스러운 대답은 아니다.
  - "실제 세계를 모델링하는 새로운 방법"
    - 얼버무리는 수준의 대답이다.
  - 캡슐화, 상속, 다형성 - OO는 이 세 가지 개념을 조합한 것이거나, OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다.

#### 캡슐화<sub><span style='color: grey'>encapsulation</span></sub>

- 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분석 바깥에서 데이터는 은닉되고 (private), 일부 함수만이 외부에 노출된다 (public).
- 캡슐화는 OO에만 국한된 것은 아니다.
  - C 언어에서도 완벽한 캡슐화가 가능하다.
    - 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현한다. 그리고 프로그램 사용자는 구현 파일에 작성된 항목에 대해서는 어떠한 방법으로도 접근할 수 없다.
  - C++에서는 C가 제공하던 완전한 캡슐화가 깨지게 된다.
    - C++ 컴파일러는 기술적인 이유 (컴파일러는 클래스의 인스턴스 크기를 알아야 한다) 로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구한다.
    - 사용자는 멤버 변수가 존재한다는 사실 자체를 알게 된다. 물론 멤버 변수에 접근하는 일은 컴파일러에서 막는다.
  - Java, C#에서는 캡슐화가 더욱 심하게 훼손된다.
    - 헤더와 구현체를 분리하는 방식을 버린다.
- 많은 OO 언어가 캡슐화를 거의 강제하지 않는다. (Smalltalk, Python, JavaScript, Lua, Ruby, ...)
- OO 프로그래밍은 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

#### 상속<sub><span style='color: grey'>inheritance</span></sub>

- 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
- OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다.
  - NamedPoint 데이터 구조에 선언된 두 변수의 순서가 Point 데이터 구조와 동일하면, NamedPoint가 마치 Point로부터 파생된 구조인 것처럼 동작하게 할 수 있다.
  - C++에서는 이 방법을 이용해서 단일 상속을 구현했다.
- OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방법으로 제공했다.

#### 다형성<sub><span style='color: grey'>polymorphism</span></sub>

- 다형성은 함수를 가리키는 포인터를 응용한 것이다.
- OO가 다형성과 관련하여 새롭게 만든 것은 전혀 없다. OO 언어는 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
- 의존성 역전<sub><span style='color: grey'>dependency inversion</span></sub>
  - 기존 소스 코드 의존성의 방향은 반드시 제어흐름<sub><span style='color: grey'>flow of control</span></sub>을 따른다.
  - 의존성 역전: 인터페이스 사이의 소스 코드 의존성 (상속 관계) 이 제어흐름과는 반대
  - OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
  - 의존성 역전으로 무엇을 할 수 있는가?
    - 배포 독립성<sub><span style='color: grey'>independent deployability</span></sub>
      - 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.
    - 개발 독립성<sub><span style='color: grey'>independent developability</span></sub>
      - 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.

#### 결론

- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

### 6장. 함수형 프로그래밍

- 핵심이 되는 개념은 람다 계산법으로 알론조 처치가 1930년대에 발명했다.
- 자바 프로그램은 가변 변수를 사용하는데, 클로저 프로그램에서는 가변 변수를 사용하지 않는다.
  - 가변 변수<sub><span style='color: grey'>mutable variable</span></sub>는 프로그램 실행 중에 상태가 변할 수 있다.
  - 함수형 언어에서 변수는 변경되지 않는다.

#### 불변성과 아키텍처

- 가변 변수로 인해 경합<sub><span style='color: grey'>race</span></sub> 문제, 교착상태<sub><span style='color: grey'>deadlock</span></sub> 조건, 동시 업데이트<sub><span style='color: grey'>concurrent update</span></sub> 문제가 발생한다.
- 불변성은 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제할 때 가능하므로, 일종의 타협이 필요하다.

#### 어떤 타협이 필요한가

- 가변성의 분리
  - 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.
    - 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
  - 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다.
    - e.g. 트랜잭션 메모리<sub><span style='color: grey'>transactional memory</span></sub>
  - **현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.**
- 이벤트 소싱
  - 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
  - 이 전략이 실현 가능하려면 애플리케이션의 수명 주기 동안 (혹은 영원히) 문제없이 동작할 정도의 저장 공간과 처리 능력이 있어야 한다.
  - 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않는다.
    - CRUD 중 CR만 수행한다.
    - 동시 업데이트 문제가 일어나지 않는다.
  - 소스 코드 버전 관리 시스템이 이 방식으로 동작한다.

### 결론

- 세 패러다임은 모두 우리에게서 무언가를 뺴앗아간다.
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
  - 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 소프트웨어 즉, 컴퓨터 프로그램은 순차<sub><span style='color: grey'>sequence</span></sub>, 분기<sub><span style='color: grey'>selection</span></sub>, 반복<sub><span style='color: grey'>iteration</span></sub>, 참조<sub><span style='color: grey'>indirection</span></sub>로 구성된다. 그 이상도 이하도 아니다.

## 3부. 설계 원칙

- 좋은 소프트웨어 시스템은 깔끔한 코드<sub><span style='color: grey'>clean code</span></sub>로부터 시작한다.
- SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.
  - 여기서 '클래스'는 단순히 함수와 데이터를 결합한 집합을 가리킨다.
- SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
  - 변경에 유연하다.
  - 이해하기 쉽다.
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
  - 여기서 '중간 수준'이란 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.
- SRP: 단일 책임 원칙<sub><span style='color: grey'>Single Responsibility Principle</span></sub>
  - 각 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
- OCP: 개방-폐쇄 원칙<sub><span style='color: grey'>Open-Closed Principle</span></sub>
  - 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다.
- LSP: 리스코프 치환 원칙<sub><span style='color: grey'>Liskov Substitution Principle</span></sub>
  - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
- ISP: 인터페이스 분리 원칙<sub><span style='color: grey'>Interface Segregation Principle</span></sub>
  - 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
- DIP: 외존성 역전 원칙<sub><span style='color: grey'>Dependency Inversion Principle</span></sub>
  - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

### 7장. SRP: 단일 책임 원칙

- 모든 모듈이 단 하나의 일만 해야 한다는 의미가 아니다.

#### SRP의 의미

- 역사적으로 다음과 같이 기술되어 왔다.
  - "단일 모듈은 변경의 이유가 오직 하나뿐이어야 한다."
- 다음과 같이 바꿔 말할 수 있다.
  - "하나의 모듈은 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다."
- 최종 버전은 다음과 같다.
  - "하나의 모듈은 오직 하나의 액터<sub><span style='color: grey'>actor</span></sub>에 대해서만 책임져야 한다."
  - 여기서 '액터'는 변경을 요청하는 한 명 이상의 사람들을 가리킨다.

#### SRP를 위반하는 징후들

- 징후 1: 우발적 중복
  - 서로 다른 액터가 의존하는 코드를 서로 분리하라.
- 징후 2: 병합
  - 소스 파일에 다양하고 많은 메소드를 포함하면 병합이 자주 발생한다. 특히 이들 메소드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 더 높다.
- 해결책
  - 가장 확실한 해결책은 데이터와 메소드를 분리하는 방식이다.
    - 아무런 메소드가 없는 간단한 데이터 구조의 클래스를 만들고, 메소드를 포함하는 클래스가 공유하도록 한다. 메소드를 포함하는 클래스들은 서로의 존재를 몰라야 한다.
    - '우연한 중복'을 피할 수 있다.
    - [단점] 메소드를 포함하는 클래스 모두를 인스턴스화하고 추적해야 한다.
  - 퍼사드<sub><span style='color: grey'>Facade</span></sub> 패턴
    - 퍼사드 클래스는 메소드를 포함하는 클래스의 객체를 생성하고, 요청된 메소드를 가지는 객체로 위임하는 일을 책임진다.
    - 기존 클래스를 유지하되, 덜 중요한 나머지 메소드들에 대한 퍼사드로 사용하는 방법도 있다.

#### 결론

- 단일 책임 원칙은 메소드와 클래스 수준의 원칙이다.
- 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다.
  - 컴포넌트 수준: 공통 폐쇄 원칙<sub><span style='color: grey'>Common Closure Principle</span></sub>
  - 아키텍처 수준: 아키텍처 경계<sub><span style='color: grey'>Architectural Boundary</span></sub>의 생성을 책임지는 변경의 축<sub><span style='color: grey'>Axis of Change</span></sub>

### 8장. OCP: 개방-폐쇄 원칙

- 1988년, 버트란트 마이어<sub><span style='color: grey'>Bertrand Meyer</span></sub>: "소프트웨어 개체<sub><span style='color: grey'>artifact</span></sub>는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."
  - 다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.

#### 사고 실험

- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고 (단일 책임 원칙<sub><span style='color: grey'>SRP</span></sub>), 이들 요소 사이의 의존성을 체계화함으로써 (의존성 역전 원칙<sub><span style='color: grey'>DIP</span></sub>) 코드 변경량을 최소화할 수 있다.
- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.
- 컴포넌트 계층구조를 이와 같이 조직화하면 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

#### 결론

- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

### 9장. LSP: 리스코프 치환 원칙

- 1988년, 바바라 리스코프<sub><span style='color: grey'>Barbara Liskov</span></sub>: "S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다."

#### LSP를 위반하는 전형적인 문제 - 정사각형/직사각형 문제

- 정사각형은 직사각형의 하위 타입으로 적합하지 않다.
  - why? 직사각형의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, 정사각형의 높이와 너비는 반드시 함께 변경된다.
- 이런 형태의 LSP 위반을 막기 위한 유일한 방법은 (if문 등을 이용해서) 직사각형이 실제로는 정사각형인지를 검사하는 메커니즘을 User에 추가하는 것이다.
  - 하지만 이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.

#### LSP와 아키텍처

- 객체 지향이 등장한 초창기에 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만, 시간이 지나면서 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.
- 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에 무슨 일이 일어나는지 관찰하는 것이다.

#### 결론

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
  - why? 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수도 있다.

### 10장. ISP: 인터페이스 분리 원칙

#### ISP와 언어

- 정적 타입 언어
  - 사용자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제한다. -> 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
- 동적 타입 언어
  - 유연하고 결합도가 낮은 시스템을 만들 수 있다.
  - why?
    - 소스 코드에 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다. -> 소스 코드 의존성이 아예 없으며, 재컴파일과 재배포가 필요없다.
- 이러한 사실로 인해 ISP를 언어와 관련된 문제라고 결론내릴 여지가 있다.

#### ISP와 아키텍처

- 일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
  - why? 불필요한 재컴파일과 재배포를 강제한다.
- 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.
  - System S -> Framework F -> Database D
  - F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 기능이 D에 포함된다고 가정하자.
  - 그 기능 때문에 D 내부가 변경되면, F를 재배포해야 할 수도 있고, 따라서 S까지 재배포해야 할지 모른다.

#### 결론

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.

### 11장. DIP: 의존성 역전 원칙

- '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상<sub><span style='color: grey'>abstraction</span></sub>에 의존하며 구체<sub><span style='color: grey'>concretion</span></sub>에는 의존하지 않는 시스템이다.
  - 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. 구체적인 대상에는 절대로 의존해서는 안 된다.
  - 동적 타입 언어에서는 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안 된다.
- DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.
  - e.g. 자바의 String 클래스
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰<sub><span style='color: grey'>volatile</span></sub> 구체적인 요소다.
  - 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수밖에 없는 모듈들이다.

#### 안정된 추상화

- 인터페이스는 구현체보다 변동성이 낮다.
  - 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다.
  - 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다.
- **안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.**
- 코딩 실천법
  - 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.
    - 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리<sub><span style='color: grey'>Abstract Factory</span></sub>를 사용하도록 강제한다.
  - 변동성이 큰 구체 클래스로부터 파생하지 말라.
    - 상속은 의존성을 가지기 때문에 신중하게 사용해야 한다.
  - 구체 함수를 오버라이드 하지 말라.
    - 대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
    - 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
  - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

#### 팩토리

- 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.
- 아키텍처 경계는 시스템을 두 가지 컴포넌트로 분리한다.
  - 추상 컴포넌트
    - 애플리케이션의 모든 고수준 업무 규칙을 포함한다.
  - 구체 컴포넌트
    - 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
- 제어흐름은 소스 코드 의존성과는 정반대 방향으로 흐른다.
- 이러한 이유로 이 원칙을 의존성 역전<sub><span style='color: grey'>Dependency Inversion</span></sub>이라고 부른다.

#### 구체 컴포넌트

- DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.
- 대다수의 시스템은 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히 이 컴포넌트를 메인(Main)이라고 부르는데, main 함수를 포함하기 때문이다.

#### 결론

- DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.
- 의존성 규칙<sub><span style='color: grey'>Dependency Rule</span></sub>: 의존성은 아키텍처 경계선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다.

## 4부. 컴포넌트 원칙

### 12장. 컴포넌트

- 컴포넌트는 시스템의 구성 요소르 배포할 수 있는 가장 작은 단위다.
- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일, 아카이브, 플러그인 등을 생성할 수 있다.
- 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

#### 컴포넌트의 간략한 역사

- 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.
  - 프로그램의 위치가 한번 결정되면, 재배치가 불가능했다.
- 라이브러리 함수에 어떻게 접근했을까?
  - 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.
    - 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.
    - 컴파일러는 소스 코드를 여러 차례 읽어야만 했다.
  - 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리했다.
    - 컴파일 시간을 단축시켰다.
    - 애플리케이션이 점점 커지면서, 할당된 공간을 넘어서게 되었다.
  - 애플리케이션을 두 개의 주소 세그먼트로 분리하여 함수 라이브러리 공간을 사이에 두고 오가며 동작하게 배치한다.
    - 프로그램과 라이브러리가 사용하는 메모리가 늘어날수록 이와 같은 단편화는 계속될 수밖에 없었다.

#### 재배치성

- 해결책은 재배치가 아니라 바이너리<sub><span style='color: grey'>relocatable binary</span></sub>였다.
- 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하였다.
  - 필요한 함수만을 로드할 수 있게 되었다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.
  - 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조<sub><span style='color: grey'>external reference</span></sub>로 생성했다.
  - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의<sub><span style='color: grey'>external definition</span></sub>로 생성했다.
  - 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다. 이렇게 링킹 로더<sub><span style='color: grey'>linking loader</span></sub>가 탄생했다.

#### 링커

- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
- 프로그램이 계속 커짐에 따라 링킹 로더가 너무 느려져서 로드와 링크가 두 단계로 분리되었다.
  - 링커<sub><span style='color: grey'>linker</span></sub>라는 별도의 애플리케이션으로 링크 과정을 처리하도록 만들었다.
  - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌다.
- 1980년대, 고수준 언어 (e.g. C) 를 사용하기 시작했다.
  - 소스 모듈은 .c 파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어졌다.
  - 각 모듈을 컴파일하는 과정은 상대적으로 빨랐지만, 전체 모듈을 컴파일하는 일은 꽤 시간이 걸렸다.
- 1960년대 ~ 1980년대에 걸쳐서 처리 과정을 더 빠르게 만들기 위해서 온갖 시도를 했지만, 프로그래머의 야심, 그리고 이로 인해 늘어난 프로그램의 크기로 인해 좌초되었다.
- 1990년대 후반, 무어의 법칙으로 인해 하드웨어의 성능이 좋아지면서 프로그래머가 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는 속도가 더 빨라지기 시작했다.
  - 이렇게 액티브 X와 공유 라이브러리 시대가 열렸고, 컴포넌트 플러그인 아키텍처<sub><span style='color: grey'>component plugin architecture</span></sub>가 탄생했다.
- 오늘날에는 .jar 파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었다.

#### 결론

- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.

### 13장. 컴포넌트 응집도

- 컴포넌트 응집도와 관련된 세 가지 원칙
  - REP: 재사용/릴리스 등가 원칙
  - CCP: 공통 폐쇄 원칙
  - CRP: 공통 재사용 원칙

#### REP: 재사용/릴리스 등가 원칙<sub><span style='color: grey'>Reuse/Release Equivalence Principle</span></sub>

> 재사용 단위는 릴리스 단위와 같다.

- 재사용/릴리스 등가 원칙<sub><span style='color: grey'>REP</span></sub>은 너무 당연해 보인다.
  - 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.
  - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.
- 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.
- REP만으로는 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들다.
  - REP의 약점은 CCP와 CRP가 지닌 강점을 통해 충분히 보완할 수 있다.
  - 실제로 CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.

#### CCP: 공통 폐쇄 원칙<sub><span style='color: grey'>Common Closure Principle</span></sub>

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

- 이 원칙은 단일 책임 원칙<sub><span style='color: grey'>SRP</span></sub>을 컴포넌트 관점에서 다시 쓴 것이다.
  - 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다.
- 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
  - 변경 모두가 단일 컴포넌트에서 발생하는 것이 낫다.
    - 해당 컴포넌트만 재배포하면 된다.
    - 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없다.
  - CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
- 이 원칙은 개방 폐쇄 원칙<sub><span style='color: grey'>OCP</span></sub>과도 밀접하게 관련되어 있다.
  - CCP에서 말하는 '폐쇄'는 OCP에서 말하는 '폐쇄'와 그 뜻이 같다.
  - 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶는다.
    - 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.

#### CRP: 공통 재사용 원칙<sub><span style='color: grey'>Common Reuse Principle</span></sub>

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- 공통 재사용 원칙<sub><span style='color: grey'>CRP</span></sub>도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
  - 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다.
    - e.g. 컨테이너<sub><span style='color: grey'>container</span></sub> 클래스와 해당 클래스의 이터레이터<sub><span style='color: grey'>iterator</span></sub> 클래스
  - 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다.
- CRP는 인터페이스 분리 원칙<sub><span style='color: grey'>ISP</span></sub>의 포괄적인 버전이다.
  - "필요하지 않은 것에 의존하지 말라."

#### 컴포넌트 응집도에 대한 균현 다이어그램

- 응집도에 대한 세 원칙이 서로 상충된다.
  - REP와 CCP는 포함<sub><span style='color: grey'>inclusive</span></sub> 원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
  - CRP는 배제<sub><span style='color: grey'>exclusive</span></sub> 원칙이며, 컴포넌트를 더욱 작게 만든다.
- 각 원칙을 포기했을 때 감수해야 할 비용
  - REP 포기: 재사용이 어렵다.
  - CCP 포기: 컴포넌트 변경이 너무 빈번하다.
  - CRP 포기: 불필요한 릴리스가 너무 빈번하다.
- 뛰어난 아키텍트는 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 또한 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야 한다.
  - e.g. 프로젝트 초기에는 CCP가 REP보다 훨씬 더 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문이다.

#### 결론

- 재사용성과 개발 가능성이라는 상충하는 힘 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다.
- 시간이 흐름에 따라 프로젝트의 초점이 개발 가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.
