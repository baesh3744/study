# 클린 아키텍처

> 로버트 C. 마틴

## 1부. 소개

### 1장. 설계와 아키텍처란?

- 설계<sub><span style='color: grey'>design</span></sub>와 아키텍처<sub><span style='color: grey'>architecture</span></sub> 사이에는 차이가 없다.
  - 일반적으로 설계는 저수준의 세부사항, 아키텍처는 고수준의 구조를 말한다.
  - 설계와 아키텍처는 개별로 존재할 수 없고, 구분 짓는 경계도 뚜렷하지 않다. 따라서 이 둘의 구분은 무의미하다.
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
  - 코드를 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.
- 자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.
- 어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장. 두 가지 가치에 대한 이야기

- 모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공한다: 행위<sub><span style='color: grey'>behavior</span></sub>와 구조<sub><span style='color: grey'>structure</span></sub>. 소프트웨어 개발자는 두 가치를 모두 높게 유지해야 하는 책임을 진다.
- 많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신이 해야 할 일의 전부라고 생각한다. 슬픈 일이지만 그들은 틀렸다!
- 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 (기계의 행위를) 변경하기 쉬워야 한다.
  - 변경사항을 적용하는 데 드는 어려움은 변경되는 범위<sub><span style='color: grey'>scope</span></sub>에 비례해야 하며, 변경사항의 형태<sub><span style='color: grey'>shape</span></sub>와는 관련이 없어야 한다.
  - 새로운 요구사항이 발생할 때마다 더 힘들어지는 이유는 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문이다.
  - 흔히 소프트웨어 개발자는 사각형 마개를 동그란 구멍에 밀어넣도록 강요받는 느낌을 받는다.
- 아키텍터는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아키텍처를 위해 투쟁하라
  - 아이젠하워 매트릭스에 따른 우선순위는 다음과 같다.
    1. 긴급하고 중요한 (행위, 기능)
    2. 긴급하지는 않지만 중요한 (아키텍처)
    3. 긴급하지만 중요하지 않은 (행위, 기능)
    4. 긴급하지도 중요하지도 않은
  - 업무 관리자와 개발자가 흔히 저지르는 실수는 긴급하지만 중요하지 않은 기능과 긴급하면서 중요한 기능을 구분하지 못한다. 이로 인해 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
  - 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.

## 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임<sub><span style='color: grey'>paradigm</span></sub>이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

### 3장. 패러다임 개요

- 구조적 프로그래밍<sub><span style='color: grey'>structured programming</span></sub>
  - 최초로 적용된 패러다임이다. (최초로 만들어진 패러다임은 아니다.)
  - 1968년, 에츠허르 비버 데이트스트라<sub><span style='color: grey'>Edsger Wybe Dijkstra</span></sub>가 발견했다.
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍<sub><span style='color: grey'>object-oriented programming</span></sub>
  - 1966년, 올레 요한 달<sub><span style='color: grey'>Ole Johan Dahl</span></sub>과 크리스텐 니가드<sub><span style='color: grey'>Kristen Nygaard</span></sub>에 의해 등장했다.
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍<sub><span style='color: grey'>functional programming</span></sub>
  - 최근에 들어서야 도입되기 시작했지만, 세 패러다임 중 가장 먼저 만들어졌다.
  - 알론조 처치<sub><span style='color: grey'>Alonzo Church</span></sub>는 어떤 수학적 문제를 해결하는 과정에서 람다<sub><span style='color: grey'>lambda</span></sub> 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.
  - 1958년, 존 매카시<sub><span style='color: grey'>John McCarthy</span></sub>가 만든 LISP 언어의 근간이 되는 개념이 람다 계산법이다.
  - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- 프로그래밍 패러다임은 앞으로도 딱 세 가지밖에 없을 것이다.
  - why?
    - 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다. 우리에게서 가져갈 수 있는 게 더 없다.
    - 이들 패러다임은 1958년 ~ 1968년에 걸친 10년 동안 모두 만들어졌다. 이후로 수십 년이 지났지만, 새롭게 등장한 패러다임은 없다.

### 4장. 구조적 프로그래밍

- 데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.
- 데이크스트라는 증명<sub><span style='color: grey'>proof</span></sub>이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.
  - 그는 수학자가 유클리드 계층구조 (공리, 정리, 따름정리, 보조정리) 를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.
  - 다시 말해, 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식
- goto
  - 모듈을 재귀적으로 분해하는 과정에 방해 -> 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없다.
  - '좋은' 사용 방식은 분기 (if/then/else) 와 반복 (do/while) 이라는 단순한 제어 구조에 해당한다.
- 뵘<sub><span style='color: grey'>Böhm</span></sub>과 야코피니<sub><span style='color: grey'>Jacopini</span></sub>: 모든 프로그램은 순차<sub><span style='color: grey'>sequence</span></sub>, 분기<sub><span style='color: grey'>selection</span></sub>, 반복<sub><span style='color: grey'>iteration</span></sub>이라는 세 가지 구조만으로 표현할 수 있다.
- 즉, 모듈을 증명 가능하게 하는 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다.
- 데이크스트라의 증명
  - 순차 구문 by 열거법
  - 분기 by 열거법
  - 반복 by 귀납법<sub><span style='color: grey'>induction</span></sub>
- 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다. (수학적인 증명의 실패)
- 수학 vs. 과학
  - 수학은 증명 가능한 서술이 참임을 입증하는 원리이다.
  - 과학은 증명 가능한 서술이 거짓임을 입증하는 원리이다.
- 소프트웨어는 과학과 같다.
  - 데이크스트라: "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다."
  - 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여준다.
  - 프로그램을 증명 가능한 세부 기능 집합으로 분해 -> 세부 기능들이 거짓임을 증명하려는 테스트가 실패 -> 이 기능들은 목표에 부합할 만큼은 충분히 참이다.
- 구조적 프로그래밍이 오늘날까지 가치 있는 이유
  - 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있다.
  - 대다수의 현대적 언어는 제약 없는 goto 문장을 지원하지 않는다.
    - 현재의 우리 모두는 구조적 프로그래머이다.
  - 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여긴다.
- **소프트웨어 아키텍처는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 (테스트하기 쉽도록) 만들기 위해 노력해야 한다.**

### 5장. 객체 지향 프로그래밍

- **좋은 아키텍처를 만드는 일은 객체 지향<sub><span style='color: grey'>OO, Object-Oriented</span></sub> 설계 원칙을 이해하고 응용하는 데서 출발한다.**
- OO란 무엇인가?
  - "데이터와 함수의 조합"
    - `o.f()`가 왠지 `f(o)`와 다르다는 의미를 내포하기 때문에 만족스러운 대답은 아니다.
  - "실제 세계를 모델링하는 새로운 방법"
    - 얼버무리는 수준의 대답이다.
  - 캡슐화, 상속, 다형성 - OO는 이 세 가지 개념을 조합한 것이거나, OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다.
- 캡슐화<sub><span style='color: grey'>encapsulation</span></sub>
  - 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분석 바깥에서 데이터는 은닉되고 (private), 일부 함수만이 외부에 노출된다 (public).
  - 캡슐화는 OO에만 국한된 것은 아니다.
    - C 언어에서도 완벽한 캡슐화가 가능하다.
      - 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현한다. 그리고 프로그램 사용자는 구현 파일에 작성된 항목에 대해서는 어떠한 방법으로도 접근할 수 없다.
    - C++에서는 C가 제공하던 완전한 캡슐화가 깨지게 된다.
      - C++ 컴파일러는 기술적인 이유 (컴파일러는 클래스의 인스턴스 크기를 알아야 한다) 로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구한다.
      - 사용자는 멤버 변수가 존재한다는 사실 자체를 알게 된다. 물론 멤버 변수에 접근하는 일은 컴파일러에서 막는다.
    - Java, C#에서는 캡슐화가 더욱 심하게 훼손된다.
      - 헤더와 구현체를 분리하는 방식을 버린다.
  - 많은 OO 언어가 캡슐화를 거의 강제하지 않는다. (Smalltalk, Python, JavaScript, Lua, Ruby, ...)
  - OO 프로그래밍은 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.
- 상속<sub><span style='color: grey'>inheritance</span></sub>
  - 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
  - OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다.
    - NamedPoint 데이터 구조에 선언된 두 변수의 순서가 Point 데이터 구조와 동일하면, NamedPoint가 마치 Point로부터 파생된 구조인 것처럼 동작하게 할 수 있다.
    - C++에서는 이 방법을 이용해서 단일 상속을 구현했다.
  - OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방법으로 제공했다.
- 다형성<sub><span style='color: grey'>polymorphism</span></sub>
  - 다형성은 함수를 가리키는 포인터를 응용한 것이다.
  - OO가 다형성과 관련하여 새롭게 만든 것은 전혀 없다. OO 언어는 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
  - 의존성 역전<sub><span style='color: grey'>dependency inversion</span></sub>
    - 기존 소스 코드 의존성의 방향은 반드시 제어흐름<sub><span style='color: grey'>flow of control</span></sub>을 따른다.
    - 의존성 역전: 인터페이스 사이의 소스 코드 의존성 (상속 관계) 이 제어흐름과는 반대
    - OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
    - 의존성 역전으로 무엇을 할 수 있는가?
      - 배포 독립성<sub><span style='color: grey'>independent deployability</span></sub>
        - 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.
      - 개발 독립성<sub><span style='color: grey'>independent developability</span></sub>
        - 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.
  - OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

### 6장. 함수형 프로그래밍

- 핵심이 되는 개념은 람다 계산법으로 알론조 처치가 1930년대에 발명했다.
- 자바 프로그램은 가변 변수를 사용하는데, 클로저 프로그램에서는 가변 변수를 사용하지 않는다.
  - 가변 변수<sub><span style='color: grey'>mutable variable</span></sub>는 프로그램 실행 중에 상태가 변할 수 있다.
  - 함수형 언어에서 변수는 변경되지 않는다.
- 불변성과 아키텍처
  - 가변 변수로 인해 경합<sub><span style='color: grey'>race</span></sub> 문제, 교착상태<sub><span style='color: grey'>deadlock</span></sub> 조건, 동시 업데이트<sub><span style='color: grey'>concurrent update</span></sub> 문제가 발생한다.
  - 불변성은 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제할 때 가능하므로, 일종의 타협이 필요하다.
- 어떤 타협이 필요한가
  - 가변성의 분리
    - 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.
      - 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
    - 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다.
      - e.g. 트랜잭션 메모리<sub><span style='color: grey'>transactional memory</span></sub>
    - **현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.**
  - 이벤트 소싱
    - 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
    - 이 전략이 실현 가능하려면 애플리케이션의 수명 주기 동안 (혹은 영원히) 문제없이 동작할 정도의 저장 공간과 처리 능력이 있어야 한다.
    - 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않는다.
      - CRUD 중 CR만 수행한다.
      - 동시 업데이트 문제가 일어나지 않는다.
    - 소스 코드 버전 관리 시스템이 이 방식으로 동작한다.

### 결론

- 세 패러다임은 모두 우리에게서 무언가를 뺴앗아간다.
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
  - 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 소프트웨어 즉, 컴퓨터 프로그램은 순차<sub><span style='color: grey'>sequence</span></sub>, 분기<sub><span style='color: grey'>selection</span></sub>, 반복<sub><span style='color: grey'>iteration</span></sub>, 참조<sub><span style='color: grey'>indirection</span></sub>로 구성된다. 그 이상도 이하도 아니다.
