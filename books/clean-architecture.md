# 클린 아키텍처

> 로버트 C. 마틴

## 1부. 소개

### 1장. 설계와 아키텍처란?

- 설계<sub><span style='color: grey'>design</span></sub>와 아키텍처<sub><span style='color: grey'>architecture</span></sub> 사이에는 차이가 없다.
  - 일반적으로 설계는 저수준의 세부사항, 아키텍처는 고수준의 구조를 말한다.
  - 설계와 아키텍처는 개별로 존재할 수 없고, 구분 짓는 경계도 뚜렷하지 않다. 따라서 이 둘의 구분은 무의미하다.
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
  - 코드를 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다.
- 자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.
- 어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장. 두 가지 가치에 대한 이야기

- 모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공한다: 행위<sub><span style='color: grey'>behavior</span></sub>와 구조<sub><span style='color: grey'>structure</span></sub>. 소프트웨어 개발자는 두 가치를 모두 높게 유지해야 하는 책임을 진다.
- 많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신이 해야 할 일의 전부라고 생각한다. 슬픈 일이지만 그들은 틀렸다!
- 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 (기계의 행위를) 변경하기 쉬워야 한다.
  - 변경사항을 적용하는 데 드는 어려움은 변경되는 범위<sub><span style='color: grey'>scope</span></sub>에 비례해야 하며, 변경사항의 형태<sub><span style='color: grey'>shape</span></sub>와는 관련이 없어야 한다.
  - 새로운 요구사항이 발생할 때마다 더 힘들어지는 이유는 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문이다.
  - 흔히 소프트웨어 개발자는 사각형 마개를 동그란 구멍에 밀어넣도록 강요받는 느낌을 받는다.
- 아키텍터는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아키텍처를 위해 투쟁하라
  - 아이젠하워 매트릭스에 따른 우선순위는 다음과 같다.
    1. 긴급하고 중요한 (행위, 기능)
    2. 긴급하지는 않지만 중요한 (아키텍처)
    3. 긴급하지만 중요하지 않은 (행위, 기능)
    4. 긴급하지도 중요하지도 않은
  - 업무 관리자와 개발자가 흔히 저지르는 실수는 긴급하지만 중요하지 않은 기능과 긴급하면서 중요한 기능을 구분하지 못한다. 이로 인해 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
  - 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.

## 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임<sub><span style='color: grey'>paradigm</span></sub>이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

### 3장. 패러다임 개요

- 구조적 프로그래밍<sub><span style='color: grey'>structured programming</span></sub>
  - 최초로 적용된 패러다임이다. (최초로 만들어진 패러다임은 아니다.)
  - 1968년, 에츠허르 비버 데이트스트라<sub><span style='color: grey'>Edsger Wybe Dijkstra</span></sub>가 발견했다.
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍<sub><span style='color: grey'>object-oriented programming</span></sub>
  - 1966년, 올레 요한 달<sub><span style='color: grey'>Ole Johan Dahl</span></sub>과 크리스텐 니가드<sub><span style='color: grey'>Kristen Nygaard</span></sub>에 의해 등장했다.
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍<sub><span style='color: grey'>functional programming</span></sub>
  - 최근에 들어서야 도입되기 시작했지만, 세 패러다임 중 가장 먼저 만들어졌다.
  - 알론조 처치<sub><span style='color: grey'>Alonzo Church</span></sub>는 어떤 수학적 문제를 해결하는 과정에서 람다<sub><span style='color: grey'>lambda</span></sub> 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.
  - 1958년, 존 매카시<sub><span style='color: grey'>John McCarthy</span></sub>가 만든 LISP 언어의 근간이 되는 개념이 람다 계산법이다.
  - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- 프로그래밍 패러다임은 앞으로도 딱 세 가지밖에 없을 것이다.
  - why?
    - 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다. 우리에게서 가져갈 수 있는 게 더 없다.
    - 이들 패러다임은 1958년 ~ 1968년에 걸친 10년 동안 모두 만들어졌다. 이후로 수십 년이 지났지만, 새롭게 등장한 패러다임은 없다.
